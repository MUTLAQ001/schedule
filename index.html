# -*- coding: utf-8 -*-

import os
import json
import logging
import asyncio
import threading # ØªÙ… Ø¥Ø¶Ø§ÙØ© Ù‡Ø°Ø§ Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù‚ÙÙ„
from dotenv import load_dotenv
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Application, CommandHandler, CallbackQueryHandler, MessageHandler,
    ConversationHandler, ContextTypes, filters
)
from telegram.error import BadRequest, Forbidden

# --- 1. Setup and Configuration ---
load_dotenv()
BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
TARGET_GROUP_ID = int(os.getenv("TARGET_GROUP_ID")) if os.getenv("TARGET_GROUP_ID") else None
ADMIN_ID = int(os.getenv("ADMIN_ID")) if os.getenv("ADMIN_ID") else None

# --- Data Files ---
TOPICS_FILE = "topics.json"
USER_MAPPING_FILE = "user_mapping.json" # Stores user_id <-> user_number
MESSAGE_MAP_FILE = "message_map.json"   # Stores bot_message_id -> original_user_id
REPLY_MAP_FILE = "reply_map.json"      # Stores group_reply_msg_id -> pm_reply_info

# --- Basic Validation ---
if not all([BOT_TOKEN, TARGET_GROUP_ID, ADMIN_ID]):
    raise ValueError("Please ensure BOT_TOKEN, TARGET_GROUP_ID, and ADMIN_ID are set in your .env file.")

# --- Logging ---
logging.basicConfig(format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO)
logger = logging.getLogger(__name__)

# --- 2. Constants ---
SUBJECT_MENU, TYPE_MENU, AWAITING_CONTENT = range(3)
(
    SHOW_ARAB, SHOW_SELM, BACK_TO_MAIN_MENU, BACK_TO_SUBJECT_MENU, FINISH_SENDING,
    SUBJECT_COMMUNICATION, SUBJECT_THINKING, SUBJECT_COMPUTER, SUBJECT_FAMILY,
    SUBJECT_ARAB_LANG, SUBJECT_ARAB_EDIT, SUBJECT_SELM_INTRO, SUBJECT_SELM_SOCIETY,
    SUBJECT_SELM_ECO, SUBJECT_SELM_POL, SUBJECT_GENERAL, SUBJECT_UNSPECIFIED,
    TYPE_EXAM, TYPE_BOOK, TYPE_SUMMARY, TYPE_OTHER, START_SENDING
) = (
    "show_arab", "show_selm", "back_main", "back_subject", "finish",
    "subj_comm", "subj_think", "subj_comp", "subj_family",
    "subj_arab_lang", "subj_arab_edit", "subj_selm_intro", "subj_selm_soc",
    "subj_selm_eco", "subj_selm_pol", "subj_general", "subj_unspecified",
    "type_exam", "type_book", "type_summary", "type_other", "start_sending"
)
SUBJECTS = {
    "Ù…Ù‡Ø§Ø±Ø§Øª Ø§Ù„Ø§ØªØµØ§Ù„": SUBJECT_COMMUNICATION, "Ù…Ù‡Ø§Ø±Ø§Øª Ø§Ù„ØªÙÙƒÙŠØ±": SUBJECT_THINKING,
    "Ø§Ù„Ø­Ø§Ø³Ø¨ Ø§Ù„Ø¢Ù„ÙŠ": SUBJECT_COMPUTER, "Ø§Ù„Ø£Ø³Ø±Ø© ÙÙŠ Ø§Ù„Ù‚Ø±Ø¢Ù†": SUBJECT_FAMILY,
    "Ø§Ù„Ù…Ù‡Ø§Ø±Ø§Øª Ø§Ù„Ù„ØºÙˆÙŠØ©": SUBJECT_ARAB_LANG, "Ø§Ù„ØªØ­Ø±ÙŠØ± Ø§Ù„Ø¹Ø±Ø¨ÙŠ": SUBJECT_ARAB_EDIT,
    "Ø§Ù„Ù…Ø¯Ø®Ù„ Ø¥Ù„Ù‰ Ø§Ù„Ø«Ù‚Ø§ÙØ© Ø§Ù„Ø¥Ø³Ù„Ø§Ù…ÙŠØ©": SUBJECT_SELM_INTRO, "Ø§Ù„Ø¥Ø³Ù„Ø§Ù… ÙˆØ¨Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¬ØªÙ…Ø¹": SUBJECT_SELM_SOCIETY,
    "Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ø§Ù‚ØªØµØ§Ø¯ÙŠ ÙÙŠ Ø§Ù„Ø¥Ø³Ù„Ø§Ù…": SUBJECT_SELM_ECO, "Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ø³ÙŠØ§Ø³ÙŠ ÙÙŠ Ø§Ù„Ø¥Ø³Ù„Ø§Ù…": SUBJECT_SELM_POL,
    "Ø¹Ø§Ù…": SUBJECT_GENERAL,
    "ØºÙŠØ± Ù…Ø­Ø¯Ø¯": SUBJECT_UNSPECIFIED,
}
SUBJECT_CODE_TO_NAME = {v: k for k, v in SUBJECTS.items()}
CONVERSATION_TIMEOUT = 3600 # 60 minutes for content submission

# --- 3. Data Management ---
# Global lock for file operations to mitigate concurrency issues (CRITICAL IMPROVEMENT)
FILE_LOCK = threading.Lock() 

def load_data(filename, default_value=None):
    if default_value is None: default_value = {}
    with FILE_LOCK:
        try:
            with open(filename, "r", encoding='utf-8') as f:
                return json.load(f)
        except (FileNotFoundError, json.JSONDecodeError):
            # ÙŠØ¶Ù…Ù† Ø£Ù† ÙŠØªÙ… ØªÙ‡ÙŠØ¦Ø© Ù…Ù„Ù user_mapping Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­ Ø¥Ø°Ø§ ÙƒØ§Ù† ÙØ§Ø±ØºÙ‹Ø§
            if filename == USER_MAPPING_FILE:
                return {"next_user_number": 1, "id_to_number": {}, "number_to_id": {}}
            return default_value

def save_data(data, filename):
    with FILE_LOCK:
        with open(filename, "w", encoding='utf-8') as f:
            json.dump(data, f, indent=4, ensure_ascii=False)

async def initialize_topics(app: Application):
    logger.info("Checking and creating forum topics...")
    topics = load_data(TOPICS_FILE)
    for name in SUBJECTS.keys():
        if name not in topics:
            try:
                # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© Ù‡ÙŠ Ù…Ø¬Ù…ÙˆØ¹Ø© Ù…Ù†ØªØ¯ÙŠØ§Øª (Supergroup with Topics enabled)
                chat_info = await app.bot.get_chat(TARGET_GROUP_ID)
                if not chat_info.is_forum:
                    logger.error(f"Target chat ID {TARGET_GROUP_ID} is not a forum chat. Topic creation skipped.")
                    # ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© ØªÙ†Ø¨ÙŠÙ‡ Ù„Ù„Ù…Ø´Ø±Ù Ù‡Ù†Ø§
                    break 

                topic = await app.bot.create_forum_topic(chat_id=TARGET_GROUP_ID, name=name)
                topics[name] = topic.message_thread_id
                logger.info(f"Created new topic: '{name}' (ID: {topic.message_thread_id})")
                await asyncio.sleep(1) # ØªØ£Ø®ÙŠØ± Ù„Ù…Ù†Ø¹ ØªØ¬Ø§ÙˆØ² Ø­Ø¯ÙˆØ¯ API
            except Exception as e:
                logger.error(f"Failed to create topic for '{name}': {e}")
    save_data(topics, TOPICS_FILE)
    logger.info("Topic check complete.")

# --- User Numbering System ---
def get_or_assign_user_number(user_id: int) -> int:
    user_mapping = load_data(USER_MAPPING_FILE)
    user_id_str = str(user_id)
    if user_id_str in user_mapping["id_to_number"]:
        return user_mapping["id_to_number"][user_id_str]
    else:
        new_number = user_mapping["next_user_number"]
        user_mapping["id_to_number"][user_id_str] = new_number
        user_mapping["number_to_id"][str(new_number)] = user_id_str
        user_mapping["next_user_number"] += 1
        save_data(user_mapping, USER_MAPPING_FILE)
        logger.info(f"Assigned User Number #{new_number} to user ID {user_id}")
        return new_number

# --- 4. Core Conversation and Media Logic ---
def get_session_prefix(context: ContextTypes.DEFAULT_TYPE, user_number: int) -> str:
    # ÙŠØªÙ… ØªØ®Ø²ÙŠÙ† Ø§Ù„Ø¨Ø§Ø¯Ø¦Ø© Ø¨Ø¹Ø¯ Ø¥Ù†Ø´Ø§Ø¦Ù‡Ø§ Ù„Ø¶Ù…Ø§Ù† Ø§Ù„Ø«Ø¨Ø§Øª Ø®Ù„Ø§Ù„ Ø§Ù„Ø¬Ù„Ø³Ø© Ø§Ù„ÙˆØ§Ø­Ø¯Ø©
    if 'session_prefix' in context.user_data:
        return context.user_data['session_prefix']

    subject_code = context.user_data.get('subject')
    type_code = context.user_data.get('type')
    prefix = ""
    user_prefix = f"<b>User #{user_number}:</b>\n"

    if subject_code == SUBJECT_GENERAL:
         prefix = f"{user_prefix}\n"
    else:
        subject_name = SUBJECT_CODE_TO_NAME.get(subject_code, "ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ")
        type_map = {TYPE_EXAM: "Ù†Ù…ÙˆØ°Ø¬_Ø§Ø®ØªØ¨Ø§Ø±", TYPE_BOOK: "ÙƒØªØ§Ø¨_Ù…Ø®Ø·Ø·", TYPE_SUMMARY: "Ù…Ù„Ø®Øµ", TYPE_OTHER: "Ù…ØªÙ†ÙˆØ¹"}
        type_hashtag = "#" + type_map.get(type_code, "Ù…Ø­ØªÙˆÙ‰")
        subject_hashtag = "#" + subject_name.replace(" ", "_").replace(":", "") # Ø¥Ø²Ø§Ù„Ø© : Ù„Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø¹Ù…Ù„ Ø§Ù„Ù‡Ø§Ø´ØªØ§Ø¬
        hashtag_prefix = f"{subject_hashtag}\n{type_hashtag}\n\n"
        prefix = f"{user_prefix}{hashtag_prefix}"
    
    context.user_data['session_prefix'] = prefix
    return prefix

async def receive_content(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    message = update.message
    if not message: return AWAITING_CONTENT

    if not context.user_data.get('subject'):
        await message.reply_text("Ø¹Ø°Ø±Ù‹Ø§ØŒ Ø§Ù†ØªÙ‡Øª Ø§Ù„Ø¬Ù„Ø³Ø©. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„Ø¨Ø¯Ø¡ Ù…Ù† Ø¬Ø¯ÙŠØ¯ Ø¨Ø§Ù„Ø¶ØºØ· Ø¹Ù„Ù‰ /start")
        return ConversationHandler.END

    user_id = update.effective_user.id
    user_number = get_or_assign_user_number(user_id)
    subject_name = SUBJECT_CODE_TO_NAME.get(context.user_data.get('subject'), "ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ")
    topics = load_data(TOPICS_FILE)
    thread_id = topics.get(subject_name)

    if not thread_id:
        await message.reply_text("Ø¹Ø°Ø±Ù‹Ø§ØŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ù…ÙˆØ¶ÙˆØ¹. ÙŠØ±Ø¬Ù‰ Ø¥Ø¨Ù„Ø§Øº Ø§Ù„Ù…Ø³Ø¤ÙˆÙ„ Ù„Ø­Ù„ Ø§Ù„Ù…Ø´ÙƒÙ„Ø©.")
        return AWAITING_CONTENT

    prefix_text = get_session_prefix(context, user_number)

    try:
        sent_message = None
        # Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ù†ØµÙŠØ©
        if message.text:
            final_text = f"{prefix_text}{message.text_html}"
            sent_message = await context.bot.send_message(
                chat_id=TARGET_GROUP_ID, message_thread_id=thread_id,
                text=final_text, parse_mode='HTML'
            )
        # Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ù„ÙˆØ³Ø§Ø¦Ø· (ØµÙˆØ±ØŒ Ù…Ù„ÙØ§ØªØŒ Ø¥Ù„Ø®)
        else:
            final_caption = f"{prefix_text}{message.caption_html or ''}".strip()
            # Ø§Ø³ØªØ®Ø¯Ø§Ù… copy() Ù„Ø¶Ù…Ø§Ù† Ø¥Ø±Ø³Ø§Ù„ Ø¬Ù…ÙŠØ¹ Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„ÙˆØ³Ø§Ø¦Ø· Ø¨Ø´ÙƒÙ„ Ù…ÙˆØ­Ø¯
            sent_message = await message.copy(
                chat_id=TARGET_GROUP_ID, message_thread_id=thread_id,
                caption=final_caption, parse_mode='HTML'
            )
        
        if sent_message:
            message_map = load_data(MESSAGE_MAP_FILE)
            # Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ù…Ù†Ø³ÙˆØ®Ø© (Ù‚Ø¯ ØªÙƒÙˆÙ† Ù‚Ø§Ø¦Ù…Ø© Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø£Ù„Ø¨ÙˆÙ… ØµÙˆØ±) Ø£Ùˆ Ø±Ø³Ø§Ù„Ø© ÙˆØ§Ø­Ø¯Ø©
            actual_message = sent_message[0] if isinstance(sent_message, list) else sent_message
            message_map[str(actual_message.message_id)] = user_id
            save_data(message_map, MESSAGE_MAP_FILE)

    except Exception as e:
        logger.error(f"Failed to send content for user {user_id} (User #{user_number}): {e}")
        await message.reply_text("Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.")

    return AWAITING_CONTENT

async def handle_unsolicited_pm(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id = update.effective_user.id
    message = update.message

    logger.info(f"Received unsolicited PM from user ID {user_id}")

    user_number = get_or_assign_user_number(user_id)
    topics = load_data(TOPICS_FILE)
    thread_id = topics.get("ØºÙŠØ± Ù…Ø­Ø¯Ø¯")

    if not thread_id:
        await message.reply_text("Ø¹Ø°Ø±Ù‹Ø§ØŒ Ø§Ù„Ù‚Ø³Ù… Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ ØºÙŠØ± Ù…ØªØ§Ø­ Ø­Ø§Ù„ÙŠÙ‹Ø§. Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ù„Ø§Ø­Ù‚Ù‹Ø§ Ø£Ùˆ Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ù…Ø± /send.")
        logger.error("The 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯' topic could not be found in topics.json.")
        return

    prefix_text = f"<b>User #{user_number}:</b>\n\n"

    try:
        sent_message = None
        if message.text:
             sent_message = await context.bot.send_message(
                chat_id=TARGET_GROUP_ID, 
                message_thread_id=thread_id, 
                text=f"{prefix_text}{message.text_html}", 
                parse_mode='HTML'
            )
        else:
             final_caption = f"{prefix_text}{message.caption_html or ''}".strip()
             sent_message = await message.copy(
                chat_id=TARGET_GROUP_ID, 
                message_thread_id=thread_id, 
                caption=final_caption, 
                parse_mode='HTML'
            )

        if sent_message:
            message_map = load_data(MESSAGE_MAP_FILE)
            actual_message = sent_message[0] if isinstance(sent_message, list) else sent_message
            message_map[str(actual_message.message_id)] = user_id
            save_data(message_map, MESSAGE_MAP_FILE)
            await message.reply_text("âœ… ØªÙ… Ø§Ø³ØªÙ„Ø§Ù… Ø±Ø³Ø§Ù„ØªÙƒ ÙˆØ¥Ø±Ø³Ø§Ù„Ù‡Ø§ Ø¥Ù„Ù‰ Ù‚Ø³Ù… <b>\"ØºÙŠØ± Ù…Ø­Ø¯Ø¯\"</b> Ø¨Ù†Ø¬Ø§Ø­. ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¨Ø¯Ø¡ ÙÙŠ Ø£ÙŠ ÙˆÙ‚Øª Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø£Ù…Ø± /send.", parse_mode='HTML')

    except Exception as e:
        logger.error(f"Failed to forward unsolicited PM from user {user_id}: {e}")
        await message.reply_text("Ø¹Ø°Ø±Ù‹Ø§ØŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„ØªÙƒ. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.")

# --- Conversation Flow Handlers (Menus, Start, Finish) ---
async def conversation_entry_point(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    get_or_assign_user_number(update.effective_user.id)
    # Ù…Ø³Ø­ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ø§Ø³ØªØ«Ù†Ø§Ø¡ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ø³ØªÙ…Ø±Ø©
    if 'session_prefix' in context.user_data: del context.user_data['session_prefix']
    if 'subject' in context.user_data: del context.user_data['subject']
    if 'type' in context.user_data: del context.user_data['type']
    
    context.user_data['chat_id'] = update.effective_chat.id
    if update.callback_query:
        await update.callback_query.answer()
    return await show_main_subject_menu(update, context)

async def show_main_subject_menu(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    keyboard = [
        [InlineKeyboardButton("Ù…ÙˆØ§Ø¯ Ø§Ù„Ø¹Ø±Ø¨", callback_data=SHOW_ARAB), InlineKeyboardButton("Ù…ÙˆØ§Ø¯ Ø§Ù„Ø³Ù„Ù…", callback_data=SHOW_SELM)],
        [InlineKeyboardButton("Ù…Ù‡Ø§Ø±Ø§Øª Ø§Ù„Ø§ØªØµØ§Ù„", callback_data=SUBJECT_COMMUNICATION), InlineKeyboardButton("Ù…Ù‡Ø§Ø±Ø§Øª Ø§Ù„ØªÙÙƒÙŠØ±", callback_data=SUBJECT_THINKING)],
        [InlineKeyboardButton("Ø§Ù„Ø­Ø§Ø³Ø¨ Ø§Ù„Ø¢Ù„ÙŠ", callback_data=SUBJECT_COMPUTER), InlineKeyboardButton("Ø§Ù„Ø£Ø³Ø±Ø© ÙÙŠ Ø§Ù„Ù‚Ø±Ø¢Ù†", callback_data=SUBJECT_FAMILY)],
        [InlineKeyboardButton("Ù…ÙˆØ¶ÙˆØ¹ Ø¹Ø§Ù…", callback_data=SUBJECT_GENERAL)]
    ]
    text = "â‘¡ Ø«Ù… Ù‚Ù… Ø¨Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…Ø§Ø¯Ø© Ø§Ù„ØªÙŠ ØªØªØ¹Ù„Ù‚ Ø¨Ø±Ø³Ø§Ù„ØªÙƒ:"
    try:
        if update.callback_query:
            await update.callback_query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
        else:
            await update.message.reply_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
    except Exception as e:
        logger.error(f"Error in show_main_subject_menu: {e}")
    return SUBJECT_MENU

async def subject_menu_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()
    choice = query.data

    if choice == BACK_TO_MAIN_MENU:
        return await show_main_subject_menu(update, context)

    if choice == SHOW_ARAB:
        keyboard = [
            [InlineKeyboardButton("Ø§Ù„Ù…Ù‡Ø§Ø±Ø§Øª Ø§Ù„Ù„ØºÙˆÙŠØ©", callback_data=SUBJECT_ARAB_LANG)], 
            [InlineKeyboardButton("Ø§Ù„ØªØ­Ø±ÙŠØ± Ø§Ù„Ø¹Ø±Ø¨ÙŠ", callback_data=SUBJECT_ARAB_EDIT)], 
            [InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ Â»", callback_data=BACK_TO_MAIN_MENU)]
        ]
        await query.edit_message_text("Ø§Ø®ØªØ± Ù…Ù† (Ù…ÙˆØ§Ø¯ Ø§Ù„Ø¹Ø±Ø¨) â†“", reply_markup=InlineKeyboardMarkup(keyboard))
    elif choice == SHOW_SELM:
        keyboard = [
            [InlineKeyboardButton("Ø§Ù„Ù…Ø¯Ø®Ù„ Ø¥Ù„Ù‰ Ø§Ù„Ø«Ù‚Ø§ÙØ© Ø§Ù„Ø¥Ø³Ù„Ø§Ù…ÙŠØ©", callback_data=SUBJECT_SELM_INTRO)], 
            [InlineKeyboardButton("Ø§Ù„Ø¥Ø³Ù„Ø§Ù… ÙˆØ¨Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¬ØªÙ…Ø¹", callback_data=SUBJECT_SELM_SOCIETY)], 
            [InlineKeyboardButton("Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ø§Ù‚ØªØµØ§Ø¯ÙŠ ÙÙŠ Ø§Ù„Ø¥Ø³Ù„Ø§Ù…", callback_data=SUBJECT_SELM_ECO)], 
            [InlineKeyboardButton("Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ø³ÙŠØ§Ø³ÙŠ ÙÙŠ Ø§Ù„Ø¥Ø³Ù„Ø§Ù…", callback_data=SUBJECT_SELM_POL)], 
            [InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ Â»", callback_data=BACK_TO_MAIN_MENU)]
        ]
        await query.edit_message_text("Ø§Ø®ØªØ± Ù…Ù† (Ù…ÙˆØ§Ø¯ Ø§Ù„Ø³Ù„Ù…) â†“", reply_markup=InlineKeyboardMarkup(keyboard))
    else:
        context.user_data['subject'] = choice
        # Ù…Ø³Ø­ Ø§Ù„Ø¨Ø§Ø¯Ø¦Ø© Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© Ù„Ø¥Ø¹Ø§Ø¯Ø© Ø­Ø³Ø§Ø¨Ù‡Ø§ Ø¨Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
        if 'session_prefix' in context.user_data: del context.user_data['session_prefix'] 
        
        if choice == SUBJECT_GENERAL:
            context.user_data['type'] = "general_post"
            subject_name = SUBJECT_CODE_TO_NAME.get(choice, "ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ")
            text = f"<blockquote>â˜‘ï¸ ØªÙ… ØªØ­Ø¯ÙŠØ¯ Ø§Ø®ØªÙŠØ§Ø±Ùƒ:\n<b>{subject_name}</b></blockquote>\n\nÙ„Ø¯ÙŠÙƒ Ø§Ù„Ø¢Ù† <b>{int(CONVERSATION_TIMEOUT/60)} Ø¯Ù‚ÙŠÙ‚Ø©</b> Ù„Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ø­ØªÙˆÙ‰. ÙŠÙ…ÙƒÙ† Ø¥Ø±Ø³Ø§Ù„ Ø¹Ø¯Ø© Ø±Ø³Ø§Ø¦Ù„ ÙˆÙ…Ù„ÙØ§Øª.\n\n"
            keyboard = [
                [InlineKeyboardButton("âœ… Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„", callback_data=FINISH_SENDING)], 
                [InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (Ù„ØªØºÙŠÙŠØ± Ø§Ù„Ù…Ø§Ø¯Ø©) Â»", callback_data=BACK_TO_MAIN_MENU)]
            ]
            await query.edit_message_text(text=text, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode='HTML')
            return AWAITING_CONTENT
        else:
            return await show_type_menu(update, context)
    return SUBJECT_MENU

async def show_type_menu(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()
    keyboard = [
        [InlineKeyboardButton("Ù†Ù…ÙˆØ°Ø¬ Ø§Ø®ØªØ¨Ø§Ø±", callback_data=TYPE_EXAM), InlineKeyboardButton("ÙƒØªØ§Ø¨ Ù…Ø®Ø·Ø·", callback_data=TYPE_BOOK)], 
        [InlineKeyboardButton("Ù…Ù„Ø®Øµ", callback_data=TYPE_SUMMARY), InlineKeyboardButton("ØºÙŠØ± Ø°Ù„Ùƒ", callback_data=TYPE_OTHER)], 
        [InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (Ù„ØªØºÙŠÙŠØ± Ø§Ù„Ù…Ø§Ø¯Ø©) Â»", callback_data=BACK_TO_MAIN_MENU)]
    ]
    await query.edit_message_text("â‚ Ù‚ÙÙ… Ø¨Ø§Ø®ØªÙŠØ§Ø± Ù†ÙˆØ¹ Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø°ÙŠ Ø³ØªÙØ±Ø³Ù„Ù‡:", reply_markup=InlineKeyboardMarkup(keyboard))
    return TYPE_MENU

async def type_menu_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()
    choice = query.data

    if choice == BACK_TO_MAIN_MENU:
        # Ù‡Ù†Ø§ Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù…Ø§Ø¯Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© ØµØ­ÙŠØ­ØŒ ÙˆÙ†Ø¨Ù‚ÙŠ Ø¹Ù„Ù‰ Ø§Ø³Ù… Ø§Ù„Ø²Ø± ÙƒÙ…Ø§ Ù‡Ùˆ Ù„Ø¹Ø¯Ù… ØªØ¹Ù‚ÙŠØ¯ Ù…Ù†Ø·Ù‚ Ø§Ù„Ø±Ø¬ÙˆØ¹
        return await show_main_subject_menu(update, context)

    context.user_data['type'] = choice
    # Ù…Ø³Ø­ Ø§Ù„Ø¨Ø§Ø¯Ø¦Ø© Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© Ù„Ø¥Ø¹Ø§Ø¯Ø© Ø­Ø³Ø§Ø¨Ù‡Ø§ Ø¨Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
    if 'session_prefix' in context.user_data: del context.user_data['session_prefix']

    subject_name = SUBJECT_CODE_TO_NAME.get(context.user_data.get('subject'), "ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ")
    type_name = {TYPE_EXAM: "Ù†Ù…ÙˆØ°Ø¬ Ø§Ø®ØªØ¨Ø§Ø±", TYPE_BOOK: "ÙƒØªØ§Ø¨ Ù…Ø®Ø·Ø·", TYPE_SUMMARY: "Ù…Ù„Ø®Øµ", TYPE_OTHER: "ØºÙŠØ± Ø°Ù„Ùƒ"}.get(choice, "ØºÙŠØ± Ù…Ø­Ø¯Ø¯")
    
    text = f"<blockquote>â˜‘ï¸ ØªÙ… ØªØ­Ø¯ÙŠØ¯ Ø§Ø®ØªÙŠØ§Ø±Ùƒ:\n<b>{subject_name} - {type_name}</b></blockquote>\n\n"
    text += f"Ù„Ø¯ÙŠÙƒ Ø§Ù„Ø¢Ù† <b>{int(CONVERSATION_TIMEOUT/60)} Ø¯Ù‚ÙŠÙ‚Ø©</b> Ù„Ø¥Ø±Ø³Ø§Ù„ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ù„ÙØ§Øª ÙˆØ§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ù…ØªØ¹Ù„Ù‚Ø© Ø¨Ù‡Ø°Ø§ Ø§Ù„Ø§Ø®ØªÙŠØ§Ø±.\n"

    if choice == TYPE_EXAM:
        text += "\nâ•<b>Ù„Ø§ ØªÙ†Ø³Ù Ø£Ù† ØªØ°ÙƒØ± Ø§Ù„Ø¢ØªÙŠ:</b>\n- Ø§Ø³Ù… Ø§Ù„Ø¯ÙƒØªÙˆØ±/Ø©.\n- Ø¬Ø²Ø¦ÙŠØ© Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±.\n- ØµØ­Ø© Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø§Øª (Ø¥Ù† ÙˆØ¬Ø¯Øª).\n- Ù†ÙˆØ¹ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±: ÙƒÙˆÙŠØ²ØŒ Ù…ÙŠØ¯ØŒ ÙØ§ÙŠÙ†Ù„."
    else:
        text += "\nØ¨Ø¥Ù…ÙƒØ§Ù†Ùƒ Ø§Ù„Ø¢Ù† Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ø­ØªÙˆÙ‰."

    keyboard = [
        [InlineKeyboardButton("âœ… Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„", callback_data=FINISH_SENDING)], 
        [InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ (Ù„ØªØºÙŠÙŠØ± Ø§Ù„Ù…Ø§Ø¯Ø©) Â»", callback_data=BACK_TO_MAIN_MENU)] # ØªÙ… Ø§Ù„Ø¥Ø¨Ù‚Ø§Ø¡ Ø¹Ù„Ù‰ BACK_TO_MAIN_MENU Ù„Ù„ØªÙ†Ø§Ø³Ù‚
    ]
    await query.edit_message_text(text=text, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode='HTML')
    return AWAITING_CONTENT

async def finish_sending(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()
    await query.edit_message_text(text="âœ… Ø´ÙƒØ±Ù‹Ø§ Ù„Ù…Ø³Ø§Ù‡Ù…ØªÙƒ. ØªÙ… Ø¥Ù†Ù‡Ø§Ø¡ Ø¬Ù„Ø³Ø© Ø§Ù„Ø¥Ø±Ø³Ø§Ù„.")
    context.user_data.clear()
    return ConversationHandler.END

# --- 5. Standard Commands and Reply/Delete Handlers ---
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user = update.effective_user
    # Ù†Ø­ØµÙ„ Ø¹Ù„Ù‰ Ø±Ù‚Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙˆÙ†Ø®Ø²Ù†Ù‡ ÙÙŠ Ù…ØªØºÙŠØ±
    user_number = get_or_assign_user_number(user.id)
    
    # Ù†Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø±Ù‚Ù… ÙÙŠ Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªØ±Ø­ÙŠØ¨ Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† Ø§Ù„Ø§Ø³Ù…
    text = (
        f"Ù…Ø±Ø­Ø¨Ù‹Ø§ Ø¨Ùƒ ÙŠØ§ ØµØ§Ø­Ø¨ Ø§Ù„Ø±Ù‚Ù… <b>#{user_number}</b> â­ï¸.\n\n"
        "Ù‡ÙÙ†Ø§ Ø¨Ø¥Ù…ÙƒØ§Ù†Ùƒ Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø©ØŒ ØµÙˆØ±Ø©ØŒ Ù…Ù„ÙØŒ Ø¥Ù„Ø®.. Ù„ÙŠØªÙ… Ù†Ø´Ø±Ù‡ ÙÙŠ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© Ø¨Ø¯ÙˆÙ† Ø¸Ù‡ÙˆØ± Ø­Ø³Ø§Ø¨Ùƒ.\n\n"
        "â€ Ù‚ÙÙ… Ø¨Ø§Ù„Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ø²Ø± Ø£Ø¯Ù†Ø§Ù‡ Ù„Ø¨Ø¯Ø¡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©:"
    )
    
    keyboard = [[InlineKeyboardButton("Ø§Ø¶ØºØ· Ù‡Ù†Ø§ Ù„Ø¨Ø¯Ø¡ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„", callback_data=START_SENDING)]]
    
    await update.message.reply_html(text, reply_markup=InlineKeyboardMarkup(keyboard))

async def handle_delete_request(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    # 1. Validation
    if not (update.message.reply_to_message and
            update.message.chat_id == TARGET_GROUP_ID and
            update.message.text and update.message.text.strip() == 'Ø­Ø°Ù'):
        return

    deleter_id = update.effective_user.id
    target_msg = update.message.reply_to_message
    target_msg_id_str = str(target_msg.message_id)

    message_map = load_data(MESSAGE_MAP_FILE)
    reply_map = load_data(REPLY_MAP_FILE)

    can_delete = False
    is_original_content = False
    is_moderator_reply = False
    
    # 2. Check if target_msg is the Bot's Forwarded Content (Key is Bot's message ID)
    original_sender_id_str = message_map.get(target_msg_id_str)
    if original_sender_id_str:
        is_original_content = True
        # Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨Ø§Ù„Ø­Ø°Ù Ù„Ù„Ù…Ø³Ø¤ÙˆÙ„ Ø£Ùˆ Ù…Ø±Ø³Ù„ Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø£ØµÙ„ÙŠ
        if deleter_id == ADMIN_ID or deleter_id == int(original_sender_id_str):
            can_delete = True
    
    # 3. Check if target_msg is a Moderator's Reply (Key is the Moderator's reply ID)
    reply_info = reply_map.get(target_msg_id_str)
    if reply_info:
        is_moderator_reply = True
        # Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨Ø§Ù„Ø­Ø°Ù Ù„Ù„Ù…Ø³Ø¤ÙˆÙ„ Ø£Ùˆ ØµØ§Ø­Ø¨ Ø§Ù„Ø±Ø¯ (Ø§Ù„Ù…Ø´Ø±Ù)
        if deleter_id == ADMIN_ID or deleter_id == int(reply_info.get("replier_id", 0)):
            can_delete = True

    # 4. Execute Deletion or Deny
    if not can_delete:
        try:
            # FIX: ØªÙ… ØªØºÙŠÙŠØ± asyncio.sleep Ø¥Ù„Ù‰ await asyncio.sleep (Ø¥ØµÙ„Ø§Ø­ Ø®Ø·Ø£ Ø­Ø±Ø¬)
            msg = await update.message.reply_text("âŒ Ù„Ø§ ÙŠÙ…ÙƒÙ†Ùƒ Ø­Ø°Ù Ù‡Ø°Ù‡ Ø§Ù„Ø±Ø³Ø§Ù„Ø©. ÙÙ‚Ø· Ù…Ø±Ø³Ù„ Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø£Ùˆ Ø§Ù„Ù…Ø³Ø¤ÙˆÙ„ Ø£Ùˆ ØµØ§Ø­Ø¨ Ø§Ù„Ø±Ø¯ ÙŠÙ…ÙƒÙ†Ù‡ Ø°Ù„Ùƒ.", quote=True)
            await asyncio.sleep(5) 
            await msg.delete()
            await update.message.delete()
        except Exception: pass
        return

    # If allowed to delete:
    
    # 4a. Handle Original Content Deletion (Ø­Ø°Ù Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ù…Ù† Ø³Ø¬Ù„ message_map)
    if is_original_content:
        if target_msg_id_str in message_map:
            del message_map[target_msg_id_str]
            save_data(message_map, MESSAGE_MAP_FILE)
    
    # 4b. Handle Moderator Reply Deletion (Ø­Ø°Ù Ø§Ù„Ø±Ø³Ø§Ù„Ø© ÙÙŠ Ø§Ù„Ù€ PM ÙˆØ­Ø°ÙÙ‡Ø§ Ù…Ù† Ø³Ø¬Ù„ reply_map)
    if is_moderator_reply:
        try:
            # Ø­Ø°Ù Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù…Ù‚Ø§Ø¨Ù„Ø© ÙÙŠ Ù…Ø­Ø§Ø¯Ø«Ø© Ø§Ù„Ù€ PM Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…
            await context.bot.delete_message(chat_id=reply_info["user_id"], message_id=reply_info["pm_message_id"])
        except Exception as e: 
            logger.warning(f"Could not delete corresponding PM message {reply_info['pm_message_id']}: {e}")
        
        # Ø¥Ø²Ø§Ù„Ø© ØªØªØ¨Ø¹ Ø§Ù„Ø±Ø¯
        del reply_map[target_msg_id_str]
        save_data(reply_map, REPLY_MAP_FILE)

    # 4c. Ø­Ø°Ù Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© ÙˆØ±Ø³Ø§Ù„Ø© 'Ø­Ø°Ù'
    try:
        await target_msg.delete()
        await update.message.delete()
    except Exception as e:
        logger.warning(f"Could not delete group message {target_msg_id_str}: {e}")


async def handle_topic_reply(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    # ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„Ø±Ø¯ Ø¹Ù„Ù‰ Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø¨ÙˆØª ÙÙŠ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©
    if not (update.message.reply_to_message and
            update.message.chat_id == TARGET_GROUP_ID and
            update.message.reply_to_message.from_user.id == context.bot.id):
        return

    # ØªØ¬Ù†Ø¨ Ù…Ø¹Ø§Ù„Ø¬Ø© ÙƒÙ„Ù…Ø© 'Ø­Ø°Ù' ÙƒØ±Ø¯ (Ù„Ø£Ù†Ù‡Ø§ ØªØ¹Ø§Ù„Ø¬ Ø¨ÙˆØ§Ø³Ø·Ø© handle_delete_request)
    if update.message.text and update.message.text.strip() == 'Ø­Ø°Ù':
        return

    replied_message_id = str(update.message.reply_to_message.message_id) # ID Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø¨ÙˆØª (Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø£ØµÙ„ÙŠ)
    message_map = load_data(MESSAGE_MAP_FILE)
    original_sender_id_str = message_map.get(replied_message_id) # ID Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£ØµÙ„ÙŠ

    if original_sender_id_str:
        original_sender_user_id = int(original_sender_id_str)
        replier_user_id = update.effective_user.id # ID Ø§Ù„Ù…Ø´Ø±Ù Ø§Ù„Ø°ÙŠ ÙŠØ±Ø¯
        
        try:
            # Ø¥Ø¹Ø§Ø¯Ø© Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù…Ø´Ø±Ù Ø¥Ù„Ù‰ Ù…Ø­Ø§Ø¯Ø«Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø®Ø§Øµ
            sent_message_in_pm = await update.message.copy(chat_id=original_sender_user_id)
            
            # ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø±Ø¯ Ù„ØªØªØ¨Ø¹Ù‡ ÙÙŠ Ø­Ø§Ù„ Ø§Ù„Ø­Ø§Ø¬Ø© Ù„Ù„Ø­Ø°Ù
            reply_map = load_data(REPLY_MAP_FILE)
            # Ø§Ù„Ù…ÙØªØ§Ø­ Ù‡Ùˆ ID Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø±Ø¯ Ø§Ù„Ø®Ø§ØµØ© Ø¨Ø§Ù„Ù…Ø´Ø±Ù ÙÙŠ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©
            reply_map[str(update.message.message_id)] = {
                "user_id": original_sender_user_id,
                "pm_message_id": sent_message_in_pm.message_id,
                "replier_id": replier_user_id
            }
            save_data(reply_map, REPLY_MAP_FILE)
            
        except Forbidden:
            await update.message.reply_text("âŒ ÙØ´Ù„ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„. ÙŠØ¨Ø¯Ùˆ Ø£Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£ØµÙ„ÙŠ Ù‚Ø§Ù… Ø¨Ø­Ø¸Ø± Ø§Ù„Ø¨ÙˆØª.", quote=True)
        except Exception as e:
            await update.message.reply_text(f"âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø­Ø§ÙˆÙ„Ø© Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø¯: {e}", quote=True)

async def handle_number_reply(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    if not update.message.text: return
    # ÙŠØ¬Ø¨ Ø£Ù† ÙŠØ¨Ø¯Ø£ Ø¨Ù†Ù…Ø· Ø±Ù‚Ù…_Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø³Ø§ÙØ© Ø«Ù… Ø§Ù„Ø±Ø³Ø§Ù„Ø©
    parts = update.message.text.split(maxsplit=1)
    if not (parts and parts[0].isdigit() and len(parts) > 1): return

    target_user_number_str = parts[0]
    reply_text = parts[1]
    
    user_mapping = load_data(USER_MAPPING_FILE)
    target_user_id_str = user_mapping.get("number_to_id", {}).get(target_user_number_str)

    if not target_user_id_str:
        await update.message.reply_text(f"âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø§Ù„Ø±Ù‚Ù… <b>#{target_user_number_str}</b>.", parse_mode='HTML', quote=True)
        return

    target_user_id = int(target_user_id_str)
    replier_user_id = update.effective_user.id

    try:
        # Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø¯ Ø¥Ù„Ù‰ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ø³ØªÙ‡Ø¯Ù ÙÙŠ Ù…Ø­Ø§Ø¯Ø«Ø© Ø®Ø§ØµØ©
        sent_message_in_pm = await context.bot.send_message(
            chat_id=target_user_id,
            text=f"<b>Ø±Ø¯ Ù…Ù† Ø£Ø­Ø¯ Ø§Ù„Ø£Ø¹Ø¶Ø§Ø¡:</b>\n\n{reply_text}",
            parse_mode='HTML'
        )
        await update.message.react("ğŸ‘") # Ø¥Ø¶Ø§ÙØ© ØªÙØ§Ø¹Ù„ Ù„ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„
        
        # ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø±Ø¯ Ù„ØªØªØ¨Ø¹Ù‡ ÙÙŠ Ø­Ø§Ù„ Ø§Ù„Ø­Ø§Ø¬Ø© Ù„Ù„Ø­Ø°Ù
        reply_map = load_data(REPLY_MAP_FILE)
        reply_map[str(update.message.message_id)] = {
            "user_id": target_user_id,
            "pm_message_id": sent_message_in_pm.message_id,
            "replier_id": replier_user_id
        }
        save_data(reply_map, REPLY_MAP_FILE)
        
    except Forbidden:
        await update.message.reply_text(f"âŒ ÙØ´Ù„ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ Ø¥Ù„Ù‰ User <b>#{target_user_number_str}</b>. ÙŠØ¨Ø¯Ùˆ Ø£Ù†Ù‡ Ù‚Ø§Ù… Ø¨Ø­Ø¸Ø± Ø§Ù„Ø¨ÙˆØª.", parse_mode='HTML', quote=True)
    except Exception as e:
        await update.message.reply_text(f"âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø­Ø§ÙˆÙ„Ø© Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø¯ Ø¥Ù„Ù‰ User <b>#{target_user_number_str}</b>: {e}", parse_mode='HTML', quote=True)

# --- 6. Admin Commands ---
async def stats(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    if update.effective_user.id != ADMIN_ID: return
    user_mapping = load_data(USER_MAPPING_FILE)
    user_count = len(user_mapping.get("id_to_number", {}))
    await update.message.reply_text(f"ğŸ“Š Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…Ø±Ù‚Ù…ÙŠÙ†: {user_count}")

async def broadcast(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    if update.effective_user.id != ADMIN_ID: return
    if not context.args:
        await update.message.reply_text("âš ï¸ Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…: <code>/broadcast [Ø±Ø³Ø§Ù„ØªÙƒ]</code>", parse_mode='HTML')
        return
        
    message_to_send = " ".join(context.args)
    user_mapping = load_data(USER_MAPPING_FILE)
    all_user_ids = list(user_mapping.get("id_to_number", {}).keys())

    if not all_user_ids:
        await update.message.reply_text("Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ù„Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¥Ø°Ø§Ø¹Ø© Ù„Ù‡Ù….")
        return

    await update.message.reply_text(f"â³ Ø¨Ø¯Ø¡ Ø§Ù„Ø¥Ø°Ø§Ø¹Ø© Ù„Ù€ {len(all_user_ids)} Ù…Ø³ØªØ®Ø¯Ù…...")
    
    success, fail = 0, 0
    for user_id_str in all_user_ids:
        try:
            # ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø¨ØµÙŠØºØ© HTML Ø¥Ø°Ø§ Ø£Ø±Ø¯Ù†Ø§ Ø§Ù„ØªÙ†Ø³ÙŠÙ‚
            await context.bot.send_message(chat_id=int(user_id_str), text=f"ğŸ“¢ <b>Ø±Ø³Ø§Ù„Ø© Ù…Ù† Ø§Ù„Ù…Ø³Ø¤ÙˆÙ„:</b>\n\n{message_to_send}", parse_mode='HTML')
            success += 1
        except (BadRequest, Forbidden):
            fail += 1
        except Exception as e:
            logger.error(f"Error sending broadcast to {user_id_str}: {e}")
            fail += 1
        await asyncio.sleep(0.05) # ØªØ£Ø®ÙŠØ± Ø¨Ø³ÙŠØ· Ø¨ÙŠÙ† ÙƒÙ„ Ø±Ø³Ø§Ù„Ø©
        
    await update.message.reply_text(f"âœ… Ø§ÙƒØªÙ…Ù„Øª Ø§Ù„Ø¥Ø°Ø§Ø¹Ø©!\n\n- âœ”ï¸ Ù†Ø¬Ø§Ø­: {success}\n- âŒ ÙØ´Ù„: {fail}")

# --- 7. Main Application Setup ---
def main() -> None:
    application = Application.builder().token(BOT_TOKEN).post_init(initialize_topics).build()
    
    conv_handler = ConversationHandler(
        entry_points=[CommandHandler("send", conversation_entry_point), CallbackQueryHandler(conversation_entry_point, pattern=f"^{START_SENDING}$")],
        states={
            SUBJECT_MENU: [CallbackQueryHandler(subject_menu_handler)],
            TYPE_MENU: [CallbackQueryHandler(type_menu_handler)],
            AWAITING_CONTENT: [
                MessageHandler(filters.ALL & ~filters.COMMAND, receive_content),
                CallbackQueryHandler(finish_sending, pattern=f"^{FINISH_SENDING}$"),
                CallbackQueryHandler(show_main_subject_menu, pattern=f"^{BACK_TO_MAIN_MENU}$")
                # ØªÙ… Ø­Ø°Ù BACK_TO_SUBJECT_MENU Ù„Ø¹Ø¯Ù… ÙˆØ¬ÙˆØ¯ Ù…Ù†Ø·Ù‚ ÙˆØ§Ø¶Ø­ Ù„Ù‡ Ù‡Ù†Ø§ ÙˆØ§Ù„Ø§Ø¹ØªÙ…Ø§Ø¯ Ø¹Ù„Ù‰ BACK_TO_MAIN_MENU
            ],
        },
        fallbacks=[CommandHandler("start", start)],
        # ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ù‡Ù„Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø«Ø§Ø¨Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯
        conversation_timeout=CONVERSATION_TIMEOUT, 
        allow_reentry=True
    )
    
    # Ù…Ø¬Ù…ÙˆØ¹Ø© 0: Ù…Ø¹Ø§Ù„Ø¬Ø© 'Ø­Ø°Ù' Ø£ÙˆÙ„Ø§Ù‹ Ù„Ø¶Ù…Ø§Ù† Ø¹Ø¯Ù… ØªØ¯Ø§Ø®Ù„Ù‡Ø§ Ù…Ø¹ Ù…Ø¹Ø§Ù„Ø¬Ø§Øª Ø§Ù„Ø±Ø¯ÙˆØ¯ Ø§Ù„Ø£Ø®Ø±Ù‰
    application.add_handler(MessageHandler(filters.TEXT & filters.REPLY & filters.Chat(chat_id=TARGET_GROUP_ID), handle_delete_request), group=0)

    # Ù…Ø¬Ù…ÙˆØ¹Ø© 1: Ø§Ù„Ø£ÙˆØ§Ù…Ø± ÙˆØ§Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª ÙˆØ§Ù„Ø±Ø¯ÙˆØ¯ ÙÙŠ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©
    application.add_handler(CommandHandler("start", start), group=1)
    application.add_handler(conv_handler, group=1)
    application.add_handler(CommandHandler("stats", stats), group=1)
    application.add_handler(CommandHandler("broadcast", broadcast), group=1)
    # Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø±Ø¯ÙˆØ¯ Ø¹Ù„Ù‰ Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ø¨ÙˆØª
    application.add_handler(MessageHandler(filters.REPLY & filters.Chat(chat_id=TARGET_GROUP_ID), handle_topic_reply), group=1)
    # Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø±Ø¯ÙˆØ¯ Ø¨Ø§Ù„Ø±Ù‚Ù… (Ø±Ø³Ø§Ù„Ø© ØªØ¨Ø¯Ø£ Ø¨Ø±Ù‚Ù… ÙÙŠ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©)
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND & ~filters.REPLY & filters.Chat(chat_id=TARGET_GROUP_ID), handle_number_reply), group=1)
    
    # Ù…Ø¬Ù…ÙˆØ¹Ø© 2: Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ø¹Ø´ÙˆØ§Ø¦ÙŠØ© ÙÙŠ Ø§Ù„Ø®Ø§Øµ
    application.add_handler(MessageHandler(filters.ChatType.PRIVATE & ~filters.COMMAND, handle_unsolicited_pm), group=2)
    
    logger.info("Bot is starting...")
    application.run_polling()

if __name__ == "__main__":
    main()

